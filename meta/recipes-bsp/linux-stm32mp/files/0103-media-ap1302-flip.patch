diff -Naurw ./drivers/media/i2c/ap1302.c ../kernel-source/drivers/media/i2c/ap1302.c
--- ./drivers/media/i2c/ap1302.c	2020-03-25 17:49:19.428634805 +0100
+++ ../kernel-source/drivers/media/i2c/ap1302.c	2020-03-25 17:50:13.650182163 +0100
@@ -36,6 +36,8 @@
 #define AP1302_XCLK_MIN 24000000
 #define AP1302_XCLK_MAX 24000000
 
+#define AP1302_TMP_BUF_SIZE     8192
+
 #define AP1302_I2C_LINE_MAX     256
 #define AP1302_BOOTDATA_WRAP    0xa000
 
@@ -59,6 +61,7 @@
 #define AP1302_REG_UPTIME_SEC           0x0E34
 #define AP1302_REG_UPTIME_SEC_FRAC      0x0E38
 
+#define AP1302_REG_ORIENTATION  		0x100c
 #define AP1302_REG_BOOTDATA_STAGE       0x6002
 #define AP1302_REG_SENSOR_SELECT		0x600c
 #define AP1302_REG_SYS_START            0x601a
@@ -289,7 +292,7 @@
 	u32 prev_sysclk, prev_hts;
 	u32 ae_low, ae_high, ae_target;
 
-	u8 tmp_buf[ 8196 ];
+	u8 tmp_buf[ AP1302_TMP_BUF_SIZE ];
 	bool pending_mode_change;
 	bool streaming;
 	bool fw_down;
@@ -647,18 +650,13 @@
 
 static int ap1302_read_reg16(struct ap1302_dev *sensor, u16 reg, u16 *val)
 {
-	u8 hi, lo;
 	int ret;
 
-	ret = ap1302_read_reg(sensor, reg, &hi);
-	if (ret)
-		return ret;
-	ret = ap1302_read_reg(sensor, reg + 1, &lo);
-	if (ret)
-		return ret;
+	ret = ap1302_read_buf(sensor, reg, (u8 *)val, 2 );
+	if ( !ret )
+		*val = be16_to_cpu( *val );
 
-	*val = ((u16)hi << 8) | (u16)lo;
-	return 0;
+	return ret;
 }
 
 static int ap1302_write_reg16(struct ap1302_dev *sensor, u16 reg, u16 val)
@@ -690,6 +688,22 @@
 	return ap1302_write_reg(sensor, reg, val);
 }
 
+static int ap1302_mod_reg16(struct ap1302_dev *sensor,
+							u16 reg, u16 mask, u16 val)
+{
+	int ret;
+	u16 readval;
+
+	ret = ap1302_read_reg16(sensor, reg, &readval );
+	if ( !ret ) {
+		readval &= ~mask;
+		readval |= ( val & mask );
+		ret = ap1302_write_reg16( sensor, reg, readval );
+	}
+
+	return ret;
+}
+
 /*
  * After trying the various combinations, reading various
  * documentations spreaded around the net, and from the various
@@ -2794,7 +2808,7 @@
 
 static int ap1302_set_ctrl_test_pattern(struct ap1302_dev *sensor, int value)
 {
-	int val;
+	u16 val;
 
 	switch ( value ) {
 		case 0:
@@ -2813,6 +2827,16 @@
 	return ap1302_write_reg16( sensor, AP1302_REG_SENSOR_SELECT, val );
 }
 
+static int ap1302_set_ctrl_hflip(struct ap1302_dev *sensor, int value)
+{
+	return ap1302_mod_reg16( sensor, AP1302_REG_ORIENTATION, 1 << 0, !!value );
+}
+
+static int ap1302_set_ctrl_vflip(struct ap1302_dev *sensor, int value)
+{
+	return ap1302_mod_reg16( sensor, AP1302_REG_ORIENTATION, 1 << 1, !!value << 1 );
+}
+
 static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
@@ -2962,6 +2986,14 @@
 			ret = ap1302_set_ctrl_test_pattern(sensor, ctrl->val);
 			break;
 
+		case V4L2_CID_HFLIP:
+			ret = ap1302_set_ctrl_hflip(sensor, ctrl->val);
+			break;
+
+		case V4L2_CID_VFLIP:
+			ret = ap1302_set_ctrl_vflip(sensor, ctrl->val);
+			break;
+
 		default:
 			ret = -EINVAL;
 			break;
@@ -2995,6 +3027,11 @@
 					     ARRAY_SIZE(test_pattern_menu) - 1,
 					     0, 0, test_pattern_menu);
 
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
 	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
 						  0, 0, link_freq_menu_items);
 	if (ctrls->link_freq)
@@ -3302,14 +3339,13 @@
 	if (ret)
 		return ret;
 
-	ret = ap1302_read_buf(sensor, AP1302_REG_CHIP_ID, (u8 *)&val, sizeof( val ) );
+	ret = ap1302_read_reg16(sensor, AP1302_REG_CHIP_ID, &val );
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to read chip identifier\n",
 			__func__);
 		goto power_off;
 	}
 
-	val = be16_to_cpu( val );
     printk( KERN_ALERT "**** %s %i  CHIP ID: 0x%04x\n", __func__, (int )__LINE__, (int )val );
 
 	if ( val != AP1302_CHIP_VERSION ) {
@@ -3438,8 +3474,8 @@
 		/* wait for new BOOTDATA_STAGE  */
 		for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
 			msleep( 2 );
-			ret = ap1302_read_buf(sensor, AP1302_REG_BOOTDATA_STAGE, (u8 *)&val, sizeof( val ) );
-			if ( ret || ( be16_to_cpu( val ) == stage ) )
+			ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_STAGE, &val );
+			if ( ret || ( val == stage ) )
 				break;
 		}
 
@@ -3490,8 +3526,8 @@
 	/* see if PLL locks */
 	for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
 		msleep( 2 );
-		ret = ap1302_read_buf(sensor, AP1302_REG_SYS_START, (u8 *)&val, sizeof( val ) );
-		if ( ret || ( be16_to_cpu( val ) & AP1302_SYS_START_PLL_LOCK ) )
+		ret = ap1302_read_reg16(sensor, AP1302_REG_SYS_START, &val );
+		if ( ret || ( val & AP1302_SYS_START_PLL_LOCK ) )
 			break;
 	}
 
@@ -3586,8 +3622,7 @@
 	/* wait for bootdata checksum to be calculated by downloaded FW */
 	for( cnt = 0 ; !ret && ( cnt < 100 ) ; cnt++ ) {
 		msleep( 2 );
-		ret = ap1302_read_buf(sensor, AP1302_REG_BOOTDATA_CHSUM, (u8 *)&val, sizeof( val ) );
-		val = be16_to_cpu( val );
+		ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_CHSUM, &val );
 		if ( !ret && ( ( val != 0 ) && ( val != p_fw_data->chksum ) ) )
 			ret = -EINVAL;
 
@@ -3608,8 +3643,7 @@
     printk( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
 
 	for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
-		ret = ap1302_read_buf(sensor, AP1302_REG_FRAME_CNT, (u8 *)&val, sizeof( val ) );
-		val = be16_to_cpu( val );
+		ret = ap1302_read_reg16(sensor, AP1302_REG_FRAME_CNT, &val );
 		printk( KERN_ALERT "**** %s %i   ret: %i   val: 0x%04x\n", __func__, (int )__LINE__, ret, val );
 		msleep( 200 );
 	}
@@ -3622,12 +3656,10 @@
 
 static int ap1302_download_fw(struct ap1302_dev *sensor)
 {
-	int ret, cnt, total, idx;
-	u16 val;
+	int ret;
 
     printk( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
 	ret = 0;
-	total = 0;
 
 	ret = request_firmware(&sensor->fw_test, "ap1302/test_pattern.bin", &sensor->i2c_client->dev);
 	printk( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
@@ -3670,7 +3702,10 @@
 
 static struct ap1302_dev *my_sensor = NULL;
 
-static ssize_t ap1302_sysfs_store16(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+/**
+ * sysfs interface function handling ".../write_reg16"
+ */
+static ssize_t ap1302_sysfs_write16(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
 {
 	int addr, val, ret;
 	u8 reg_buf[4];
@@ -3689,11 +3724,39 @@
 	return count;
 }
 
+/**
+ * sysfs interface function handling ".../dump"
+ */
+static ssize_t ap1302_sysfs_dump(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int addr, len, ret;
+
+	if ( ( my_sensor != NULL ) && ( sscanf( buf, "%x %x", &addr, &len ) == 2 ) ) {
+		mutex_lock(&my_sensor->lock);
+		if ( len > AP1302_TMP_BUF_SIZE )
+			len = AP1302_TMP_BUF_SIZE;
+
+		ret = ap1302_read_buf(my_sensor, addr, my_sensor->tmp_buf, len );
+		if ( !ret )
+			hex_dump( my_sensor->tmp_buf, len, addr );
+
+		mutex_unlock(&my_sensor->lock);
+	}
+
+	return count;
+}
+
 
-static struct kobj_attribute sysfs_attr = {
+static struct kobj_attribute ap1302_sysfs_attr_write16 = {
 	.attr = { .name = "write_reg16", .mode = VERIFY_OCTAL_PERMISSIONS(0220) },
 	.show = NULL,
-	.store = ap1302_sysfs_store16,
+	.store = ap1302_sysfs_write16,
+};
+
+static struct kobj_attribute ap1302_sysfs_attr_dump = {
+	.attr = { .name = "dump", .mode = VERIFY_OCTAL_PERMISSIONS(0220) },
+	.show = NULL,
+	.store = ap1302_sysfs_dump,
 };
 
 
@@ -3875,12 +3938,16 @@
 	my_sensor = sensor;
 	path = kobject_get_path(&dev->kobj, GFP_KERNEL);
 	if ( path != NULL ) {
-		ret = sysfs_create_file(&dev->kobj, &sysfs_attr.attr);
-		printk( KERN_ALERT "**** %s %i   ret: %i   path: /sys%s/%s\n", __func__, (int )__LINE__, ret, path, sysfs_attr.attr.name );
+		ret = sysfs_create_file(&dev->kobj, &ap1302_sysfs_attr_write16.attr);
+		printk( KERN_ALERT "**** %s %i   ret: %i   path: /sys%s/%s\n", __func__, (int )__LINE__, ret, path, ap1302_sysfs_attr_write16.attr.name );
 	}
 	else
 		printk( KERN_ALERT "**** %s %i   path: NULL\n", __func__, (int )__LINE__ );
 
+	if ( !ret ) {
+		ret = sysfs_create_file(&dev->kobj, &ap1302_sysfs_attr_dump.attr);
+		printk( KERN_ALERT "**** %s %i   ret: %i   path: /sys%s/%s\n", __func__, (int )__LINE__, ret, path, ap1302_sysfs_attr_dump.attr.name );
+	}
 
 	return 0;
 
@@ -3898,6 +3965,14 @@
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ap1302_dev *sensor = to_ap1302_dev(sd);
 
+	if ( sensor->fw_test != NULL )
+		release_firmware( sensor->fw_test );
+	if ( sensor->fw_sensor != NULL )
+		release_firmware( sensor->fw_sensor );
+
+	sysfs_remove_file(&client->dev.kobj, &ap1302_sysfs_attr_write16.attr);
+	sysfs_remove_file(&client->dev.kobj, &ap1302_sysfs_attr_dump.attr);
+
 	v4l2_async_unregister_subdev(&sensor->sd);
 	mutex_destroy(&sensor->lock);
 	media_entity_cleanup(&sensor->sd.entity);
